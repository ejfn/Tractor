import {
  Card,
  CardMemory,
  Combo,
  ComboType,
  GameContext,
  GameState,
  PlayerId,
  PlayerMemory,
  Rank,
  Suit,
  TrumpInfo,
  TrickPosition,
} from "../../types";
import { isTrump } from "../../game/gameHelpers";

/**
 * Void Exploitation - Advanced suit void analysis and strategic exploitation
 *
 * Provides sophisticated void detection, analysis, and strategic exploitation
 * for optimal tactical advantage in Tractor/Shengji gameplay.
 */

/**
 * Create a minimal CardMemory fallback when memory is not available
 */
function createMinimalCardMemory(): CardMemory {
  return {
    playedCards: [],
    trumpCardsPlayed: 0,
    pointCardsPlayed: 0,
    suitDistribution: {},
    playerMemories: {},
    cardProbabilities: [],
    roundStartCards: 25,
    tricksAnalyzed: 0,
  };
}

export interface VoidExploitationAnalysis {
  // Void Detection
  confirmedVoids: Record<PlayerId, Suit[]>; // Definitely void suits per player
  probableVoids: Record<PlayerId, VoidProbability[]>; // Likely void suits with probability
  trumpVoidPlayers: PlayerId[]; // Players confirmed or likely void in trump

  // Strategic Opportunities
  exploitableVoids: VoidExploitationOpportunity[]; // Specific exploitation chances
  voidBasedLeadRecommendations: VoidBasedLead[]; // Optimal leading strategies
  voidDefenseStrategies: VoidDefenseStrategy[]; // Defensive void management

  // Tactical Insights
  voidAdvantageScore: number; // Overall void advantage (0-1 scale)
  optimalVoidExploitationMove: Combo | null; // Best void exploitation play
  voidRiskAssessment: VoidRiskFactor[]; // Risks from our own voids

  // Advanced Analysis
  multiSuitVoidPatterns: MultiSuitVoidPattern[]; // Complex void combinations
  voidTimingRecommendations: VoidTimingStrategy; // When to exploit voids
}

export interface VoidProbability {
  suit: Suit;
  probability: number; // 0.0 to 1.0
  confidence: number; // How certain we are about this probability
  evidenceBasis: string[]; // What led to this assessment
}

export interface VoidExploitationOpportunity {
  targetPlayer: PlayerId;
  voidSuit: Suit;
  exploitationType:
    | "force_trump"
    | "safe_lead"
    | "point_collection"
    | "tactical_advantage"
    | "setup_teammate";
  exploitationCards: Card[]; // Cards we can use to exploit this void
  expectedOutcome: string;
  successProbability: number; // 0.0 to 1.0
  strategicValue: number; // How valuable this exploitation is
}

export interface VoidBasedLead {
  leadCard: Card;
  leadCombo: Combo;
  targetVoids: PlayerId[]; // Players this lead exploits
  strategicGoal:
    | "isolate_trump"
    | "collect_points"
    | "force_waste"
    | "setup_teammate";
  expectedResponse: Record<PlayerId, string>; // Predicted responses
  successRate: number; // Historical/calculated success rate
}

export interface VoidDefenseStrategy {
  threatLevel: "low" | "moderate" | "high" | "critical";
  threatenedSuits: Suit[];
  defensiveRecommendations: string[];
  preventiveActions: VoidPreventionAction[];
  fallbackStrategies: string[];
}

export interface VoidPreventionAction {
  actionType:
    | "conserve_suit"
    | "distribute_risk"
    | "force_opponent_reveal"
    | "trump_preparation";
  specificCards: Card[];
  reasoning: string;
  urgencyLevel: number; // 0.0 to 1.0
}

export interface MultiSuitVoidPattern {
  playerId: PlayerId;
  voidSuits: Suit[];
  patternType:
    | "sequential_elimination"
    | "strategic_dumping"
    | "forced_void"
    | "natural_distribution";
  tacticalImplications: string[];
  exploitationWindow: number; // Tricks remaining to exploit this
}

export interface VoidTimingStrategy {
  immediateOpportunities: VoidExploitationOpportunity[]; // Act now
  midGameOpportunities: VoidExploitationOpportunity[]; // Act in 2-4 tricks
  endGameOpportunities: VoidExploitationOpportunity[]; // Act in final tricks
  optimalSequencing: VoidSequenceRecommendation[];
}

export interface VoidSequenceRecommendation {
  sequence: string[]; // Ordered list of actions
  reasoning: string;
  expectedOutcome: string;
  riskLevel: number; // 0.0 to 1.0
}

export interface VoidRiskFactor {
  riskType:
    | "suit_shortage"
    | "trump_depletion"
    | "isolation_risk"
    | "forced_revelation";
  affectedSuits: Suit[];
  riskLevel: number; // 0.0 to 1.0
  mitigationStrategies: string[];
  urgency: "low" | "moderate" | "high" | "immediate";
}

/**
 * Comprehensive void exploitation analysis
 */
export function analyzeVoidExploitation(
  cardMemory: CardMemory,
  gameState: GameState,
  context: GameContext,
  trumpInfo: TrumpInfo,
  currentPlayerId: PlayerId,
): VoidExploitationAnalysis {
  // Gather all confirmed and probable voids
  const confirmedVoids = extractConfirmedVoids(cardMemory);
  const probableVoids = analyzeProbableVoids(cardMemory, gameState, trumpInfo);
  const trumpVoidPlayers = identifyTrumpVoidPlayers(cardMemory);

  // Analyze strategic opportunities
  const exploitableVoids = identifyExploitationOpportunities(
    confirmedVoids,
    probableVoids,
    gameState,
    context,
    trumpInfo,
    currentPlayerId,
  );

  const voidBasedLeadRecommendations = generateVoidBasedLeads(
    exploitableVoids,
    gameState,
    context,
    trumpInfo,
    currentPlayerId,
  );

  const voidDefenseStrategies = analyzeVoidDefenseNeeds(
    cardMemory,
    gameState,
    currentPlayerId,
  );

  // Calculate tactical insights
  const voidAdvantageScore = calculateVoidAdvantageScore(
    exploitableVoids,
    confirmedVoids,
    probableVoids,
    currentPlayerId,
  );

  const optimalVoidExploitationMove = selectOptimalVoidExploitationMove(
    exploitableVoids,
    context,
  );

  const voidRiskAssessment = assessVoidRisks(
    cardMemory,
    gameState,
    currentPlayerId,
    trumpInfo,
  );

  // Advanced analysis
  const multiSuitVoidPatterns = analyzeMultiSuitVoidPatterns(
    confirmedVoids,
    probableVoids,
    cardMemory,
  );

  const voidTimingRecommendations = analyzeVoidTiming(
    exploitableVoids,
    context,
    gameState,
  );

  return {
    confirmedVoids,
    probableVoids,
    trumpVoidPlayers,
    exploitableVoids,
    voidBasedLeadRecommendations,
    voidDefenseStrategies,
    voidAdvantageScore,
    optimalVoidExploitationMove,
    voidRiskAssessment,
    multiSuitVoidPatterns,
    voidTimingRecommendations,
  };
}

/**
 * Extract confirmed voids from card memory
 */
function extractConfirmedVoids(
  cardMemory: CardMemory,
): Record<PlayerId, Suit[]> {
  const confirmedVoids: Record<PlayerId, Suit[]> = {} as Record<
    PlayerId,
    Suit[]
  >;

  Object.entries(cardMemory.playerMemories).forEach(([playerId, memory]) => {
    if (memory) {
      confirmedVoids[playerId as PlayerId] = Array.from(memory.suitVoids);
    }
  });

  return confirmedVoids;
}

/**
 * Analyze probable voids based on play patterns and card distribution
 */
function analyzeProbableVoids(
  cardMemory: CardMemory,
  gameState: GameState,
  trumpInfo: TrumpInfo,
): Record<PlayerId, VoidProbability[]> {
  const probableVoids: Record<PlayerId, VoidProbability[]> = {} as Record<
    PlayerId,
    VoidProbability[]
  >;

  Object.entries(cardMemory.playerMemories).forEach(([playerId, memory]) => {
    if (memory) {
      const playerVoids: VoidProbability[] = [];

      // Analyze each suit for void probability
      Object.values(Suit).forEach((suit) => {
        if (suit === Suit.None) return; // Skip placeholder

        // Skip if already confirmed void
        if (memory.suitVoids.has(suit)) return;

        // Calculate void probability based on various factors
        const voidProb = calculateSuitVoidProbability(
          playerId as PlayerId,
          suit,
          memory,
          cardMemory,
          gameState,
          trumpInfo,
        );

        if (voidProb.probability > 0.3) {
          // Only include significant probabilities
          playerVoids.push(voidProb);
        }
      });

      probableVoids[playerId as PlayerId] = playerVoids;
    }
  });

  return probableVoids;
}

/**
 * Calculate void probability for a specific player and suit
 */
function calculateSuitVoidProbability(
  playerId: PlayerId,
  suit: Suit,
  playerMemory: PlayerMemory,
  cardMemory: CardMemory,
  gameState: GameState,
  trumpInfo: TrumpInfo,
): VoidProbability {
  let probability = 0.0;
  let confidence = 0.5;
  const evidenceBasis: string[] = [];

  // Factor 1: Cards played in this suit vs estimated hand size
  const cardsPlayedInSuit = playerMemory.knownCards.filter(
    (card: Card) => card.suit === suit && !isTrump(card, trumpInfo),
  ).length;

  if (cardsPlayedInSuit > 0 && playerMemory.estimatedHandSize <= 5) {
    probability += 0.4;
    confidence += 0.2;
    evidenceBasis.push(
      `Played ${cardsPlayedInSuit} cards in ${suit} with small hand`,
    );
  }

  // Factor 2: Forced trump plays when suit was led
  let forcedTrumpCount = 0;
  gameState.tricks.forEach((trick) => {
    const leadCard = trick.plays[0]?.cards[0];
    const playerPlay = trick.plays.find((play) => play.playerId === playerId);

    if (
      leadCard &&
      leadCard.suit === suit &&
      !isTrump(leadCard, trumpInfo) &&
      playerPlay?.cards[0] &&
      isTrump(playerPlay.cards[0], trumpInfo)
    ) {
      forcedTrumpCount++;
    }
  });

  if (forcedTrumpCount > 0) {
    probability += forcedTrumpCount * 0.3;
    confidence += 0.3;
    evidenceBasis.push(
      `Forced trump ${forcedTrumpCount} times when ${suit} led`,
    );
  }

  // Factor 3: Long absence from suit
  const tricksAnalyzed = cardMemory.tricksAnalyzed;
  if (tricksAnalyzed > 3 && cardsPlayedInSuit === 0) {
    probability += 0.2;
    evidenceBasis.push(`No ${suit} cards seen in ${tricksAnalyzed} tricks`);
  }

  // Factor 4: Pattern analysis (conservative estimate)
  if (playerMemory.estimatedHandSize <= 3 && cardsPlayedInSuit === 0) {
    probability += 0.3;
    confidence += 0.1;
    evidenceBasis.push(`Very small hand with no ${suit} evidence`);
  }

  // Clamp values
  probability = Math.min(1.0, probability);
  confidence = Math.min(1.0, confidence);

  return {
    suit,
    probability,
    confidence,
    evidenceBasis,
  };
}

/**
 * Identify players who are trump void
 */
function identifyTrumpVoidPlayers(cardMemory: CardMemory): PlayerId[] {
  const trumpVoidPlayers: PlayerId[] = [];

  Object.entries(cardMemory.playerMemories).forEach(([playerId, memory]) => {
    if (memory?.trumpVoid) {
      trumpVoidPlayers.push(playerId as PlayerId);
    }
  });

  return trumpVoidPlayers;
}

/**
 * Identify specific void exploitation opportunities
 */
function identifyExploitationOpportunities(
  confirmedVoids: Record<PlayerId, Suit[]>,
  probableVoids: Record<PlayerId, VoidProbability[]>,
  gameState: GameState,
  context: GameContext,
  trumpInfo: TrumpInfo,
  currentPlayerId: PlayerId,
): VoidExploitationOpportunity[] {
  const opportunities: VoidExploitationOpportunity[] = [];
  const currentPlayer = gameState.players.find((p) => p.id === currentPlayerId);

  if (!currentPlayer) return opportunities;

  // Analyze confirmed voids - differentiate between teammates and opponents
  Object.entries(confirmedVoids).forEach(([playerId, voidSuits]) => {
    voidSuits.forEach((voidSuit) => {
      // Find cards we can use to exploit this void
      const exploitationCards = currentPlayer.hand.filter(
        (card) => card.suit === voidSuit && !isTrump(card, trumpInfo),
      );

      if (exploitationCards.length > 0) {
        const targetPlayerId = playerId as PlayerId;
        const isTeammateVoid = isTeammate(
          gameState,
          targetPlayerId,
          currentPlayerId,
        );

        if (isTeammateVoid) {
          // 🤝 TEAMMATE VOID - Smart point collection strategy
          const teammateStrategy = analyzeTeammateVoidStrategy(
            targetPlayerId,
            voidSuit,
            exploitationCards,
            context.memoryContext?.cardMemory || createMinimalCardMemory(),
            gameState,
            context,
            trumpInfo,
            currentPlayerId,
          );

          if (teammateStrategy.strategy !== "avoid_leading") {
            opportunities.push({
              targetPlayer: targetPlayerId,
              voidSuit,
              exploitationType: teammateStrategy.exploitationType,
              exploitationCards,
              expectedOutcome: `${teammateStrategy.reasoning} Expected: ${teammateStrategy.expectedPoints} points for team.`,
              successProbability:
                teammateStrategy.strategy === "lead_for_points" ? 0.85 : 0.65,
              strategicValue: teammateStrategy.expectedPoints + 20, // Bonus for team coordination
            });
          }
        } else {
          // ⚔️ OPPONENT VOID - Aggressive exploitation
          opportunities.push({
            targetPlayer: targetPlayerId,
            voidSuit,
            exploitationType: "force_trump",
            exploitationCards,
            expectedOutcome: `Force ${playerId} to use trump or discard from other suits`,
            successProbability: 0.95, // High confidence for confirmed voids
            strategicValue: calculateVoidExploitationValue(
              targetPlayerId,
              voidSuit,
              exploitationCards,
              gameState,
              currentPlayerId,
              context,
            ),
          });
        }
      }
    });
  });

  // Analyze probable voids - also differentiate between teammates and opponents
  Object.entries(probableVoids).forEach(([playerId, voidProbs]) => {
    voidProbs.forEach((voidProb) => {
      if (voidProb.probability > 0.6) {
        // High probability voids worth exploiting
        const exploitationCards = currentPlayer.hand.filter(
          (card) => card.suit === voidProb.suit && !isTrump(card, trumpInfo),
        );

        if (exploitationCards.length > 0) {
          const targetPlayerId = playerId as PlayerId;
          const isTeammateVoid = isTeammate(
            gameState,
            targetPlayerId,
            currentPlayerId,
          );

          if (isTeammateVoid) {
            // 🤝 TEAMMATE PROBABLE VOID - Cautious point collection strategy
            const teammateStrategy = analyzeTeammateVoidStrategy(
              targetPlayerId,
              voidProb.suit,
              exploitationCards,
              context.memoryContext?.cardMemory || createMinimalCardMemory(),
              gameState,
              context,
              trumpInfo,
              currentPlayerId,
            );

            // Only pursue if strategy is strong and probability is high
            if (
              teammateStrategy.strategy === "lead_for_points" &&
              voidProb.probability > 0.75
            ) {
              opportunities.push({
                targetPlayer: targetPlayerId,
                voidSuit: voidProb.suit,
                exploitationType: teammateStrategy.exploitationType,
                exploitationCards,
                expectedOutcome: `Probable teammate void: ${teammateStrategy.reasoning}`,
                successProbability:
                  voidProb.probability * voidProb.confidence * 0.8, // Reduce for uncertainty
                strategicValue:
                  (teammateStrategy.expectedPoints + 10) * voidProb.probability,
              });
            }
          } else {
            // ⚔️ OPPONENT PROBABLE VOID - Standard exploitation
            opportunities.push({
              targetPlayer: targetPlayerId,
              voidSuit: voidProb.suit,
              exploitationType: "safe_lead",
              exploitationCards,
              expectedOutcome: `Likely force ${playerId} to reveal void or use trump`,
              successProbability: voidProb.probability * voidProb.confidence,
              strategicValue:
                calculateVoidExploitationValue(
                  targetPlayerId,
                  voidProb.suit,
                  exploitationCards,
                  gameState,
                  currentPlayerId,
                  context,
                ) * voidProb.probability,
            });
          }
        }
      }
    });
  });

  return opportunities.sort((a, b) => b.strategicValue - a.strategicValue);
}

/**
 * Calculate the strategic value of exploiting a specific void
 */
function calculateVoidExploitationValue(
  targetPlayer: PlayerId,
  voidSuit: Suit,
  exploitationCards: Card[],
  gameState: GameState,
  currentPlayerId: PlayerId,
  context: GameContext,
): number {
  let value = 0;

  // Base value for forcing decisions
  value += 10;

  // Higher value if target is opponent
  const isOpponent = !isTeammate(gameState, targetPlayer, currentPlayerId);
  if (isOpponent) {
    value += 20;
  }

  // Higher value for high-ranking exploitation cards
  exploitationCards.forEach((card) => {
    if (card.rank === "A" || card.rank === "K") {
      value += 15; // Strong cards are valuable for exploitation
    } else if (card.points && card.points > 0) {
      value += card.points; // Point cards add direct value
    }
  });

  // Position-based bonuses
  switch (context.trickPosition) {
    case TrickPosition.First:
      value += 25; // Leading player gets maximum exploitation value
      break;
    case TrickPosition.Second:
      value += 15; // Good positioning for exploitation
      break;
    case TrickPosition.Third:
      value += 10; // Moderate positioning
      break;
    case TrickPosition.Fourth:
      value += 5; // Limited exploitation value as last player
      break;
  }

  return value;
}

/**
 * Check if a player is a teammate
 */
function isTeammate(
  gameState: GameState,
  playerId: PlayerId,
  currentPlayerId: PlayerId,
): boolean {
  // Get current player's team from gameState
  const currentPlayer = gameState.players.find((p) => p.id === currentPlayerId);
  const targetPlayer = gameState.players.find((p) => p.id === playerId);

  if (!currentPlayer || !targetPlayer) {
    return false;
  }

  // Players are teammates if they're on the same team
  return currentPlayer.team === targetPlayer.team;
}

/**
 * Calculate points still available in opponent hands for a specific suit
 */
function calculateOpponentPointsInSuit(
  suit: Suit,
  cardMemory: CardMemory,
  gameState: GameState,
  currentPlayerId: PlayerId,
  trumpInfo: TrumpInfo,
): number {
  // Point cards in this suit: 5s, 10s, Kings
  const pointRanks = [Rank.Five, Rank.Ten, Rank.King];
  let totalOpponentPoints = 0;

  pointRanks.forEach((rank) => {
    // Count how many of this point card have been played
    const playedCount = cardMemory.playedCards.filter(
      (card) =>
        card.suit === suit && card.rank === rank && !isTrump(card, trumpInfo),
    ).length;

    // Total of this point card type (2 in deck)
    const totalInDeck = 2;
    const remainingCount = totalInDeck - playedCount;

    // Calculate points per card
    const pointsPerCard = rank === Rank.Five ? 5 : 10; // 5s=5pts, 10s&Kings=10pts

    // Estimate how many are in opponent hands (simplified)
    // Assume they're distributed among non-teammate players
    const estimatedOpponentCards = Math.floor(remainingCount * 0.7); // Conservative estimate

    totalOpponentPoints += estimatedOpponentCards * pointsPerCard;
  });

  return totalOpponentPoints;
}

/**
 * Get list of opponent player IDs
 */
function getOpponents(
  currentPlayerId: PlayerId,
  gameState: GameState,
): PlayerId[] {
  // Find current player's team
  const currentPlayer = gameState.players.find((p) => p.id === currentPlayerId);
  if (!currentPlayer) return [];

  // Return all players on the opposite team
  return gameState.players
    .filter((p) => p.team !== currentPlayer.team)
    .map((p) => p.id);
}

/**
 * Estimate if teammate can trump (using memory analysis)
 */
function estimateTeammateTrumpAvailable(
  teammateId: PlayerId,
  cardMemory: CardMemory,
  gameState: GameState,
): boolean {
  // Use card memory to get teammate's memory data
  const teammateMemory = cardMemory.playerMemories[teammateId];
  if (!teammateMemory) {
    // Fallback to simple analysis if no memory available
    const recentTrumps = gameState.tricks
      .slice(-3)
      .filter((trick) =>
        trick.plays.some(
          (play) =>
            play.playerId === teammateId &&
            play.cards.some((card) => isTrump(card, gameState.trumpInfo)),
        ),
      );
    return recentTrumps.length < 2;
  }

  // Use memory data to estimate trump availability
  // If player is not trump void, assume they still have trump cards
  return !teammateMemory.trumpVoid;
}

/**
 * Analyze teammate void for point collection opportunity
 */
function analyzeTeammateVoidStrategy(
  teammateId: PlayerId,
  voidSuit: Suit,
  exploitationCards: Card[],
  cardMemory: CardMemory,
  gameState: GameState,
  context: GameContext,
  trumpInfo: TrumpInfo,
  currentPlayerId: PlayerId,
): {
  strategy: "lead_for_points" | "avoid_leading" | "conditional";
  reasoning: string;
  expectedPoints: number;
  exploitationType:
    | "point_collection"
    | "setup_teammate"
    | "tactical_advantage";
} {
  // Calculate points available in opponent hands for this suit
  const opponentPoints = calculateOpponentPointsInSuit(
    voidSuit,
    cardMemory,
    gameState,
    currentPlayerId,
    trumpInfo,
  );

  // Check if teammate can likely trump
  const teammateCanTrump = estimateTeammateTrumpAvailable(
    teammateId,
    cardMemory,
    gameState,
  );

  // Calculate our point cards in this suit
  const ourPointCards = exploitationCards.filter(
    (card) => card.points && card.points > 0,
  );
  const ourPoints = ourPointCards.reduce(
    (sum, card) => sum + (card.points || 0),
    0,
  );

  // Determine game phase
  const tricksPlayed = gameState.tricks.length;
  const gamePhase =
    tricksPlayed < 5 ? "early" : tricksPlayed < 15 ? "mid" : "late";

  // Decision logic
  if (opponentPoints >= 15 && teammateCanTrump) {
    return {
      strategy: "lead_for_points",
      reasoning: `Opponents have ${opponentPoints} points in ${voidSuit}. Lead to force them to give points to teammate.`,
      expectedPoints: Math.min(opponentPoints + ourPoints, 25), // Cap realistic expectation
      exploitationType: "point_collection",
    };
  }

  if (gamePhase === "late" && opponentPoints >= 5 && teammateCanTrump) {
    return {
      strategy: "conditional",
      reasoning: `Late game: ${opponentPoints} points available. Consider if team needs points.`,
      expectedPoints: opponentPoints + ourPoints,
      exploitationType: "setup_teammate",
    };
  }

  if (ourPoints >= 10 && teammateCanTrump && opponentPoints >= 5) {
    return {
      strategy: "lead_for_points",
      reasoning: `We have ${ourPoints} points, opponents have ${opponentPoints}. Good opportunity for team point collection.`,
      expectedPoints: ourPoints + Math.floor(opponentPoints * 0.6), // Conservative estimate
      exploitationType: "setup_teammate",
    };
  }

  return {
    strategy: "avoid_leading",
    reasoning: `Low opportunity: opponent points=${opponentPoints}, teammate trump=${teammateCanTrump}, our points=${ourPoints}`,
    expectedPoints: 0,
    exploitationType: "tactical_advantage",
  };
}

/**
 * Generate void-based leading recommendations
 */
function generateVoidBasedLeads(
  exploitableVoids: VoidExploitationOpportunity[],
  gameState: GameState,
  context: GameContext,
  trumpInfo: TrumpInfo,
  currentPlayerId: PlayerId,
): VoidBasedLead[] {
  const leads: VoidBasedLead[] = [];

  // Only generate leads if we're in leading position
  if (context.trickPosition !== TrickPosition.First) {
    return leads;
  }

  exploitableVoids.forEach((opportunity) => {
    if (opportunity.exploitationCards.length > 0) {
      const leadCard = opportunity.exploitationCards[0]; // Use strongest card
      const isTeammateTarget = isTeammate(
        gameState,
        opportunity.targetPlayer,
        currentPlayerId,
      );

      // Determine strategic goal based on exploitation type and target
      let strategicGoal:
        | "isolate_trump"
        | "collect_points"
        | "force_waste"
        | "setup_teammate";
      let expectedResponse: Record<PlayerId, string>;

      if (isTeammateTarget) {
        // 🤝 TEAMMATE VOID LEAD
        strategicGoal =
          opportunity.exploitationType === "point_collection"
            ? "collect_points"
            : "setup_teammate";
        expectedResponse = {
          [opportunity.targetPlayer]: "Trump to collect points for team",
        } as Record<PlayerId, string>;

        // Add expected responses for opponents
        getOpponents(currentPlayerId, gameState).forEach((opponentId) => {
          expectedResponse[opponentId] =
            "Must follow suit, contributing points";
        });
      } else {
        // ⚔️ OPPONENT VOID LEAD
        strategicGoal =
          opportunity.exploitationType === "force_trump"
            ? "isolate_trump"
            : "force_waste";
        expectedResponse = {
          [opportunity.targetPlayer]:
            "Forced to trump or discard valuable cards",
        } as Record<PlayerId, string>;
      }

      leads.push({
        leadCard,
        leadCombo: {
          cards: [leadCard],
          type: ComboType.Single,
          value: leadCard.points ? leadCard.points + 10 : 10, // Higher value for point cards
          isBreakingPair: false,
        },
        targetVoids: [opportunity.targetPlayer],
        strategicGoal,
        expectedResponse,
        successRate: opportunity.successProbability,
      });
    }
  });

  return leads.sort((a, b) => b.successRate - a.successRate);
}

/**
 * Placeholder implementations for remaining functions
 */
function analyzeVoidDefenseNeeds(
  cardMemory: CardMemory,
  gameState: GameState,
  currentPlayerId: PlayerId,
): VoidDefenseStrategy[] {
  return [
    {
      threatLevel: "low",
      threatenedSuits: [],
      defensiveRecommendations: ["Monitor opponent void patterns"],
      preventiveActions: [],
      fallbackStrategies: ["Maintain suit distribution"],
    },
  ];
}

function calculateVoidAdvantageScore(
  exploitableVoids: VoidExploitationOpportunity[],
  confirmedVoids: Record<PlayerId, Suit[]>,
  probableVoids: Record<PlayerId, VoidProbability[]>,
  currentPlayerId: PlayerId,
): number {
  let score = 0;

  // Add value for exploitable opportunities
  exploitableVoids.forEach((opportunity) => {
    score += opportunity.strategicValue * opportunity.successProbability;
  });

  // Normalize to 0-1 scale
  return Math.min(1.0, score / 100);
}

function selectOptimalVoidExploitationMove(
  exploitableVoids: VoidExploitationOpportunity[],
  context: GameContext,
): Combo | null {
  if (exploitableVoids.length === 0) return null;

  const bestOpportunity = exploitableVoids[0]; // Already sorted by strategic value

  return {
    cards: [bestOpportunity.exploitationCards[0]],
    type: ComboType.Single,
    value: bestOpportunity.strategicValue,
    isBreakingPair: false,
  };
}

function assessVoidRisks(
  cardMemory: CardMemory,
  gameState: GameState,
  currentPlayerId: PlayerId,
  trumpInfo: TrumpInfo,
): VoidRiskFactor[] {
  const risks: VoidRiskFactor[] = [];

  const currentPlayer = gameState.players.find((p) => p.id === currentPlayerId);
  if (!currentPlayer) return risks;

  // Analyze suit distribution risks
  const suitCounts: Record<string, number> = {};
  currentPlayer.hand.forEach((card) => {
    if (!isTrump(card, trumpInfo)) {
      suitCounts[card.suit] = (suitCounts[card.suit] || 0) + 1;
    }
  });

  Object.entries(suitCounts).forEach(([suit, count]) => {
    if (count <= 2) {
      risks.push({
        riskType: "suit_shortage",
        affectedSuits: [suit as Suit],
        riskLevel: count === 1 ? 0.8 : 0.5,
        mitigationStrategies: ["Conserve remaining cards", "Avoid early plays"],
        urgency: count === 1 ? "high" : "moderate",
      });
    }
  });

  return risks;
}

function analyzeMultiSuitVoidPatterns(
  confirmedVoids: Record<PlayerId, Suit[]>,
  probableVoids: Record<PlayerId, VoidProbability[]>,
  cardMemory: CardMemory,
): MultiSuitVoidPattern[] {
  const patterns: MultiSuitVoidPattern[] = [];

  Object.entries(confirmedVoids).forEach(([playerId, voids]) => {
    if (voids.length >= 2) {
      patterns.push({
        playerId: playerId as PlayerId,
        voidSuits: voids,
        patternType: "sequential_elimination",
        tacticalImplications: [
          "High trump concentration",
          "Limited suit options",
        ],
        exploitationWindow: 3, // Assume 3 tricks remaining to exploit
      });
    }
  });

  return patterns;
}

function analyzeVoidTiming(
  exploitableVoids: VoidExploitationOpportunity[],
  context: GameContext,
  gameState: GameState,
): VoidTimingStrategy {
  return {
    immediateOpportunities: exploitableVoids.filter(
      (v) => v.successProbability > 0.8,
    ),
    midGameOpportunities: exploitableVoids.filter(
      (v) => v.successProbability > 0.6 && v.successProbability <= 0.8,
    ),
    endGameOpportunities: exploitableVoids.filter(
      (v) => v.successProbability <= 0.6,
    ),
    optimalSequencing: [
      {
        sequence: [
          "Exploit high-probability voids first",
          "Save trump forcing for endgame",
        ],
        reasoning: "Maximize certainty of exploitation",
        expectedOutcome: "Force opponent trump usage early",
        riskLevel: 0.3,
      },
    ],
  };
}
