import { describe, it, expect, beforeEach } from '@jest/globals';
import { analyzeVoidExploitation } from '../../src/ai/analysis/voidExploitation';
import { createCardMemory } from '../../src/ai/aiCardMemory';
import { createGameContext } from '../../src/ai/aiGameContext';
import { initializeGame } from '../../src/utils/gameInitialization';
import { Card } from '../../src/types/card';
import { GameState, PlayerId, Suit, Rank, TrickPosition } from '../../src/types';

describe('Void Exploitation System', () => {
  let gameState: GameState;

  beforeEach(() => {
    gameState = initializeGame();
  });

  describe('Void Detection and Analysis', () => {
    it('should detect confirmed voids from card memory', () => {
      // Set up a scenario where Bot1 has played trump when spades were led
      const cardMemory = createCardMemory(gameState);
      
      // Simulate Bot1 being void in spades
      cardMemory.playerMemories[PlayerId.Bot1].suitVoids.add(Suit.Spades);
      
      const context = createGameContext(gameState, PlayerId.Human);
      context.trickPosition = TrickPosition.First; // Human is leading
      
      const voidAnalysis = analyzeVoidExploitation(
        cardMemory,
        gameState,
        context,
        gameState.trumpInfo,
        PlayerId.Human
      );

      expect(voidAnalysis.confirmedVoids[PlayerId.Bot1]).toContain(Suit.Spades);
      expect(voidAnalysis.confirmedVoids[PlayerId.Bot1]).toHaveLength(1);
    });

    it('should identify void exploitation opportunities', () => {
      const cardMemory = createCardMemory(gameState);
      
      // Set up Bot1 as void in Hearts
      cardMemory.playerMemories[PlayerId.Bot1].suitVoids.add(Suit.Hearts);
      
      // Give human some hearts to exploit the void
      gameState.players[0].hand = [
        Card.createCard(Suit.Hearts, Rank.King, 0),
        Card.createCard(Suit.Hearts, Rank.Queen, 0),
        Card.createCard(Suit.Spades, Rank.Ace, 0),
      ];
      
      const context = createGameContext(gameState, PlayerId.Human);
      context.trickPosition = TrickPosition.First;
      
      const voidAnalysis = analyzeVoidExploitation(
        cardMemory,
        gameState,
        context,
        gameState.trumpInfo,
        PlayerId.Human
      );

      expect(voidAnalysis.exploitableVoids.length).toBeGreaterThan(0);
      
      const heartExploitation = voidAnalysis.exploitableVoids.find(
        opp => opp.voidSuit === Suit.Hearts && opp.targetPlayer === PlayerId.Bot1
      );
      
      expect(heartExploitation).toBeDefined();
      expect(heartExploitation?.exploitationType).toBe('force_trump');
      expect(heartExploitation?.successProbability).toBeGreaterThan(0.9);
    });

    it('should generate void-based leading recommendations', () => {
      const cardMemory = createCardMemory(gameState);
      
      // Bot2 is void in Clubs
      cardMemory.playerMemories[PlayerId.Bot2].suitVoids.add(Suit.Clubs);
      
      // Human has clubs to exploit
      gameState.players[0].hand = [
        Card.createCard(Suit.Clubs, Rank.Ace, 0),
        Card.createCard(Suit.Clubs, Rank.Ten, 0), // Point card
        Card.createCard(Suit.Spades, Rank.Five, 0),
      ];
      
      const context = createGameContext(gameState, PlayerId.Human);
      context.trickPosition = TrickPosition.First;
      
      const voidAnalysis = analyzeVoidExploitation(
        cardMemory,
        gameState,
        context,
        gameState.trumpInfo,
        PlayerId.Human
      );

      expect(voidAnalysis.voidBasedLeadRecommendations.length).toBeGreaterThan(0);
      
      const clubLead = voidAnalysis.voidBasedLeadRecommendations.find(
        lead => lead.leadCard.suit === Suit.Clubs
      );
      
      expect(clubLead).toBeDefined();
      expect(clubLead?.strategicGoal).toBe('collect_points');
      expect(clubLead?.targetVoids).toContain(PlayerId.Bot2);
    });

    it('should calculate appropriate void advantage scores', () => {
      const cardMemory = createCardMemory(gameState);
      
      // Set up multiple void advantages
      cardMemory.playerMemories[PlayerId.Bot1].suitVoids.add(Suit.Hearts);
      cardMemory.playerMemories[PlayerId.Bot2].suitVoids.add(Suit.Clubs);
      cardMemory.playerMemories[PlayerId.Bot3].trumpVoid = true;
      
      // Give human cards to exploit these voids
      gameState.players[0].hand = [
        Card.createCard(Suit.Hearts, Rank.King, 0),
        Card.createCard(Suit.Clubs, Rank.Queen, 0),
        Card.createCard(Suit.Spades, Rank.Ace, 0),
      ];
      
      const context = createGameContext(gameState, PlayerId.Human);
      context.trickPosition = TrickPosition.First;
      
      const voidAnalysis = analyzeVoidExploitation(
        cardMemory,
        gameState,
        context,
        gameState.trumpInfo,
        PlayerId.Human
      );

      expect(voidAnalysis.voidAdvantageScore).toBeGreaterThan(0.5);
      expect(voidAnalysis.exploitableVoids.length).toBeGreaterThanOrEqual(2);
      expect(voidAnalysis.trumpVoidPlayers).toContain(PlayerId.Bot3);
    });
  });

  describe('Void Risk Assessment', () => {
    it('should identify suit shortage risks', () => {
      const cardMemory = createCardMemory(gameState);
      
      // Give human a hand with suit shortages
      gameState.players[0].hand = [
        Card.createCard(Suit.Hearts, Rank.King, 0), // Only one heart
        Card.createCard(Suit.Spades, Rank.Ace, 0),
        Card.createCard(Suit.Spades, Rank.Queen, 0),
        Card.createCard(Suit.Spades, Rank.Jack, 0),
      ];
      
      const context = createGameContext(gameState, PlayerId.Human);
      
      const voidAnalysis = analyzeVoidExploitation(
        cardMemory,
        gameState,
        context,
        gameState.trumpInfo,
        PlayerId.Human
      );

      const suitShortageRisks = voidAnalysis.voidRiskAssessment.filter(
        risk => risk.riskType === 'suit_shortage'
      );
      
      expect(suitShortageRisks.length).toBeGreaterThan(0);
      
      const heartRisk = suitShortageRisks.find(
        risk => risk.affectedSuits.includes(Suit.Hearts)
      );
      
      expect(heartRisk).toBeDefined();
      expect(heartRisk?.riskLevel).toBeGreaterThan(0.5);
      expect(heartRisk?.urgency).toBe('high');
    });
  });

  describe('Strategic Integration', () => {
    it('should provide optimal void exploitation moves', () => {
      const cardMemory = createCardMemory(gameState);
      
      // Set up clear void exploitation scenario
      cardMemory.playerMemories[PlayerId.Bot1].suitVoids.add(Suit.Hearts);
      
      gameState.players[0].hand = [
        Card.createCard(Suit.Hearts, Rank.Ace, 0), // Can exploit Bot1 void
        Card.createCard(Suit.Spades, Rank.Five, 0),
      ];
      
      const context = createGameContext(gameState, PlayerId.Human);
      context.trickPosition = TrickPosition.First;
      
      const voidAnalysis = analyzeVoidExploitation(
        cardMemory,
        gameState,
        context,
        gameState.trumpInfo,
        PlayerId.Human
      );

      expect(voidAnalysis.optimalVoidExploitationMove).not.toBeNull();
      
      if (voidAnalysis.optimalVoidExploitationMove) {
        expect(voidAnalysis.optimalVoidExploitationMove.cards).toHaveLength(1);
        expect(voidAnalysis.optimalVoidExploitationMove.cards[0].suit).toBe(Suit.Hearts);
      }
    });

    it('should handle scenarios with no void exploitation opportunities', () => {
      const cardMemory = createCardMemory(gameState);
      
      // No confirmed voids, limited hand
      gameState.players[0].hand = [
        Card.createCard(Suit.Spades, Rank.Seven, 0),
        Card.createCard(Suit.Hearts, Rank.Six, 0),
      ];
      
      const context = createGameContext(gameState, PlayerId.Human);
      
      const voidAnalysis = analyzeVoidExploitation(
        cardMemory,
        gameState,
        context,
        gameState.trumpInfo,
        PlayerId.Human
      );

      expect(voidAnalysis.voidAdvantageScore).toBeLessThan(0.3);
      expect(voidAnalysis.exploitableVoids).toHaveLength(0);
      expect(voidAnalysis.optimalVoidExploitationMove).toBeNull();
    });
  });
});